## 1089. 复写零

### 题目传送门

[点击这里](https://leetcode.cn/problems/duplicate-zeros/)

### 解题思路

这道题如果不考虑空间复杂度的话，方法有很多，但是如果要原地修改的话并不算是一道简单题，至少是中等难度。正常思考是可以使用一个数组遇到`0`就添加两次，其他的添加一次，或者是用两个指针指向两个数组，遇到`0`新数组移动两格，直到新数组的指针移动到原数组的长度位置，然后从后向前添加，这也是我们这道题的大体思路，如果不想使用新数组的话，我们就可以在原先的数组上使用双指针，效果同理，只需要考虑一种情况就是数组的结尾如果有一个单独的`0`，说明有一个`0`没有添加，而是超出了长度。

### 代码

```go
func duplicateZeros(arr []int)  {
    // 正反两次遍历
    n := len(arr)
    // 起始与栈顶
    // 假设
    i, top := -1, 0
    for top < n {
        i ++
        // 遇到不为0的元素栈顶只加1，为0的要添加两个0，栈顶移动2格
        if arr[i] != 0 {
            top++
        }else {
            top += 2
        }
    }
    // 从后向前遍历
    j := n-1
    // 此种情况top如果等于n+1了，只有一种可能就是top在n-1的情况下top+=2了，也就是最后一个0只能修改一次。比如原数组[1,2,3,0]->[1,2,3,0]
    if top == n + 1 {
        // 结尾置0处理，i、j双指针都移动
        arr[j] = 0
        j --
        i --
    }
    for j >= 0 {
        // j每次赋值才会移动，i只有在完整添加完一次后才会移动
        arr[j] = arr[i] 
        j --
        if arr[i] == 0 {
            arr[j] = arr[i]
            j --
        }
        i --
    }
}
```
## 31. 下一个排列

### 题目传送门

[点击这里](https://leetcode-cn.com/problems/next-permutation/)

### 解题思路

这道题是中等题、双指针类型题里的好题，题干要求要原地操作，所以可以想到双指针来做。但是这道题只看代码可能会有些不好理解，这里需要自己梳理遍流程能好一些。对于这道题，如果我们想要找到数组的**下一个排列**，我们其实是想让数的变化幅度尽可能的小，所以我们要做的其实是找到数组中的两个数，交换位置，然后对前面数后面的数组重新排序，这么说可能有些不好理解，举个例子`[4,5,2,6,3,1]`，我们要做的就是将`2`和`3`换个位置，得到`[4,5,3,6,2,1]`，然后再变成`[4,5,3,1,2,6]`，而至于怎么找到`2`和`3`呢，这里要用到的就是双指针，要交换的左右两个数组，需要让左边的数尽可能的靠右，右边的数尽可能靠左，这样子才能使变化幅度很小，所以我们从后往前遍历，当碰到第一个不是升序的数，就是**左边的数**，然后再从后往前遍历，当碰到第一个比**左边的数**大的数即**右边的数**，这样子换位后，会保证原先**左边的数**索引后面的数组是按照降序排列的，比如上述例子中的`[3,6,2,1]`这一段，然后只需要将`[6,2,1]`这一段翻转即可。

```go
func nextPermutation(nums []int) {
    n := len(nums)
	// 从倒数第二个数开始找到第一个不是升序的数，即左边的数
    i := n - 2
    for i >= 0 && nums[i] >= nums[i+1] {
        i--
    }
    if i >= 0 {
		// 从最后一个数开始找到第一个比左边的数大的数，即右边的数
        j := n - 1
        for j >= 0 && nums[i] >= nums[j] {
            j--
        }
		// 交换左右两个数
        nums[i], nums[j] = nums[j], nums[i]
    }
	// 将左边的数后面的数组翻转
    reverse(nums[i+1:])
}

func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}
```
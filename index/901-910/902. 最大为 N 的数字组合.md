## 902. 最大为 N 的数字组合

### 题目传送门

[点击这里](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/)

### 解题思路

这道题的方法使用的是数位dp，首先可以明确假设由digits中的数字组成的位数如果小于n的位数的话，那么一定是小于n的，我们用动态规划`dp[i][0]`表示由digits构成的前i位数字且小于n的前i位的数字个数，`dp[i][1]`表示由digits构成且等于n的前i位数字的个数，由此得出`dp[i][1]`只能是0和1，举个例子，假设`n = 2345`，`digits = ['1','2','3','4']`，所以`dp[1][0],dp[2][0],dp[3][0],dp[4][0]`表示小于`2,23,234,2345`的合法数个数，而`dp[1][1],dp[2][1],dp[3][1],dp[4][1]`分别表示等于`2,23,234,2345`的合法个数。如果digits中字符为m个，数字n的前j位为`num[j]`，官方解中的`dp[i][0]=m+dp[i−1][0]×m+dp[i−1][1]×C[i], i > 1`，这个比较难理解，这里的`m`，表示的是只有1位的数字，在`i>1`的情况下，肯定满足条件，主要是后面两部分，`dp[i-1][0]×m`表示的是前i-1位小于n的前i-1位后跟着任意一个数字都满足条件，而后面的`dp[i-1][1]×C[i]`表示的是前i-1等于n的前i-1位后跟着小于第i位n，即`n[i]`的数字个数，同样就能理解出来，在`i=1`的情况下，也就是1位，就是小于`n[i]`的数字个数，即`C[i]`。

### 代码

```go
func atMostNGivenDigitSet(digits []string, n int) int {
    m := len(digits)
    s := strconv.Itoa(n)
    k := len(s)
    dp := make([][2]int, k+1)
    dp[0][1] = 1
    // 从i=1开始，遍历到k位，即n的长度为k
    for i := 1; i <= k; i++ {
    	// 遍历全部数字，注意这里的前i位，对应到n的i-1，因为是索引
        for _, d := range digits {
        	// 如果等于s[i-1]，则dp[i][1]直接等于dp[i-1][1]
            if d[0] == s[i-1] {
                dp[i][1] = dp[i-1][1]
            } else if d[0] < s[i-1] { // 如果小于s[i-1]，则dp[i][0]，前i位小于n前i位的的个数，可以加上前i-1位等于n前i-1位的，由d[0]作为末尾数字
                dp[i][0] += dp[i-1][1]
            } else {
                break
            }
        }
        // 如果i>1，按照上面的公式，还要加上这两个
        if i > 1 {
            dp[i][0] += m + dp[i-1][0]*m
        }
    }
    return dp[k][0] + dp[k][1]
}

```
